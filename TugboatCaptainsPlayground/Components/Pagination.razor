@using Microsoft.AspNetCore.Components
@using TugboatCaptainsPlayground.Services.Interfaces

<div class="sticky-pagination @Class">
    <div class="sticky-pagination-content">
        <nav aria-label="Paginação">
            <ul class="pagination mb-0">
                <li class="page-item @(State.CurrentPage <= 1 ? "disabled" : "")">
                    <button class="page-link" @onclick="async () => await ChangePage(State.CurrentPage - 1)" disabled="@(State.CurrentPage <= 1)">‹ Anterior</button>
                </li>
                @{
                    const int maxVisiblePages = 5;
                    if (State.TotalCount <= maxVisiblePages)
                    {
                        // Mostrar todas as páginas se o total for menor que o máximo visível
                        for (int i = 1; i <= State.TotalCount; i++)
                        {
                            var pageNumber = i;
                            <li class="page-item @(State.CurrentPage == pageNumber ? "active" : "")">
                                <button class="page-link" @onclick="async () => await ChangePage(pageNumber)">@pageNumber</button>
                            </li>
                        }
                    }
                    else
                    {
                        // Sempre mostrar a primeira página
                        <li class="page-item @(State.CurrentPage == 1 ? "active" : "")">
                            <button class="page-link" @onclick="async () => await ChangePage(1)">1</button>
                        </li>

                        // Calcular intervalo ao redor da página atual
                        var rangeStart = Math.Max(2, State.CurrentPage - 1);
                        var rangeEnd = Math.Min(State.TotalCount - 1, State.CurrentPage + 1);

                        // Mostrar reticências após a primeira página, se necessário
                        if (rangeStart > 2)
                        {
                            <li class="page-item disabled">
                                <span class="page-link">...</span>
                            </li>
                        }

                        // Mostrar páginas ao redor da página atual
                        for (int i = rangeStart; i <= rangeEnd; i++)
                        {
                            var pageNumber = i;
                            <li class="page-item @(State.CurrentPage == pageNumber ? "active" : "")">
                                <button class="page-link" @onclick="async () => await ChangePage(pageNumber)">@pageNumber</button>
                            </li>
                        }

                        // Mostrar reticências antes da última página, se necessário
                        if (rangeEnd < State.TotalCount - 1)
                        {
                            <li class="page-item disabled">
                                <span class="page-link">...</span>
                            </li>
                        }

                        // Sempre mostrar a última página
                        <li class="page-item @(State.CurrentPage == State.TotalCount ? "active" : "")">
                            <button class="page-link" @onclick="async () => await ChangePage(State.TotalCount)">@State.TotalCount</button>
                        </li>
                    }
                }
                <li class="page-item @(State.CurrentPage >= State.TotalCount ? "disabled" : "")">
                    <button class="page-link" @onclick="async () => await ChangePage(State.CurrentPage + 1)" disabled="@(State.CurrentPage >= State.TotalCount)">Próximo ›</button>
                </li>
            </ul>
        </nav>

        <div class="ms-3 d-none d-md-block">
            Mostrando @((State.CurrentPage - 1) * State.PageSize + 1) a @Math.Min(State.CurrentPage * State.PageSize, State.TotalCount) de @State.TotalCount
        </div>
       
    </div>
</div>

<style>
    .sticky-pagination {
        position: sticky;
        bottom: 0;
        background-color: var(--bs-body-bg);
        z-index: 1000;
        padding: 1rem;
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        border-radius: 0.375rem;
        margin-top: 1.5rem;
    }

    .sticky-pagination-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    @@media (max-width: 768px) {
        .sticky-pagination {
            position: static;
            margin-top: 1rem;
        }

        .sticky-pagination-content {
            justify-content: center;
        }
    }
</style>

@code {
    [Parameter]
    public string Class { get; set; } = string.Empty;

    [Parameter]
    required public IPaginates State { get; set; }

    [Parameter]
    public EventCallback<int> OnPageChange { get; set; }

    private async Task ChangePage(int page)
    {
        if (page < 1 || page > State.TotalCount)
            return;

        await OnPageChange.InvokeAsync(page);
    }
}
