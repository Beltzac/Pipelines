@page "/slot-calculator"
@using System.Globalization
@using BlazorDateRangePicker
@using Common.Models
@using Common.Services
@using Common.Services.Interfaces
@using Common.Utils
@using TugboatCaptainsPlayground.Services
@using Microsoft.Extensions.Logging
@using TugboatCaptainsPlayground.Components.Shared
@inject SlotCalculatorStateService StateService
@inject IConfigurationService ConfigService
@inject IJSRuntime JSRuntime
@inject ILogger<SlotCalculatorPage> _logger
@inject ToastService toastService
@implements IDisposable
@inject OracleOpsService OracleOpsService

<StickyFilter>
    <div class="d-flex flex-wrap gap-3">
        <!-- Seção de Filtros e Parâmetros de Entrada -->
        <div class="col-md-4">
            <label class="form-label">Período</label>
            <DateRangePicker
                TimePicker="true" TimePicker24Hour="true"
                TimePickerSeconds="true" AutoApply="true" DateFormat="@($"dd/MM/yyyy HH:mm:ss")"
                StartDate="StateService.StartDate" EndDate="StateService.EndDate" OnRangeSelect="OnRangeSelect"
                class="form-control" />
        </div>
        <div class="col-md-3">
            <label class="form-label">Ambiente Oracle:</label>
            <EnvironmentSelector
                Environments="oracleEnvironments"
                @bind-SelectedEnvironmentName="StateService.SelectedOracleEnvironment" />
        </div>
        
        <!-- Parâmetros do Algoritmo com Dicas (Hints) para Gestão -->
        <div class="col-md-2">
            <label class="form-label" title="Estimativa de quantos TEUs cada caminhão movimenta em média (fator de conversão Truck -> TEU).">
                Média TEU/Caminhão <i class="bi bi-info-circle-fill text-muted" style="font-size: 0.8em;"></i>
            </label>
            <input type="number" class="form-control" @bind="StateService.AvgTeuPerTruck" step="0.1" />
        </div>
        <div class="col-md-2">
            <label class="form-label" title="Fator de Reserva: Porcentagem da capacidade operacional (Gate/Equipamentos) que deve ser mantida livre para imprevistos.">
                Fator Reserva (%) <i class="bi bi-info-circle-fill text-muted" style="font-size: 0.8em;"></i>
            </label>
            <div class="input-group">
                <input type="number" class="form-control" @bind="ReservePercent" step="1" min="0" max="100" />
                <span class="input-group-text">%</span>
            </div>
        </div>
        <div class="col-md-2">
            <label class="form-label" title="Controla a suavidade da curva de slots. Valores mais altos evitam mudanças bruscas na abertura de agendamentos.">
                Suavização <i class="bi bi-info-circle-fill text-muted" style="font-size: 0.8em;"></i>
            </label>
            <input type="number" class="form-control" @bind="StateService.EasingStrength" step="0.1" min="0" max="0.99" />
        </div>
        <div class="col-md-2">
            <label class="form-label" title="Meta de ocupação ideal como porcentagem da capacidade máxima do pátio.">
                Meta de Estoque (%) <i class="bi bi-info-circle-fill text-muted" style="font-size: 0.8em;"></i>
            </label>
            <div class="input-group">
                <input type="number" class="form-control" @bind="TargetPercent" step="1" min="0" max="100" />
                <span class="input-group-text">%</span>
            </div>
            <small class="text-muted">(@StateService.TargetYardTeu.ToString("N0") TEUs)</small>
        </div>
        <div class="col-md-2">
            <label class="form-label" title="Capacidade física máxima do pátio.">
                Capacidade Máx (TEU)
            </label>
            <input type="number" class="form-control" @bind="StateService.MaxYardTeu" />
        </div>

        <!-- Botões de Ação -->
        <div class="col-md-12 mt-2">
            @if (StateService.IsLoading)
            {
                <button class="btn btn-secondary" @onclick="CancelCalculation">Cancelar</button>
            }
            else
            {
                <button class="btn btn-primary" @onclick="CalculateSlots">Calcular</button>
            }

            <button class="btn btn-secondary" @onclick="ResetAllZoom" title="Restaura o zoom de todos os gráficos para o período total">Resetar Zoom</button>
        </div>
    </div>
</StickyFilter>

<CustomProgressBar IsLoading="@StateService.IsLoading" Label="Calculando..." />

<!-- Card: Taxas Calculadas -->
<div class="card mb-3">
    <div class="card-header">
        <h5 class="mb-0">Taxas Operacionais Calculadas</h5>
    </div>
    <div class="card-body">
        <div class="row">
            <div class="col-md-6">
                <h6>Taxas de Navio (Vessel)</h6>
                <p>Embarque: @StateService.VesselLoadRate.ToString("F2") TEU/h</p>
                <p>Descarga: @StateService.VesselUnloadRate.ToString("F2") TEU/h</p>
            </div>
            <div class="col-md-6">
                <h6>Taxas de Trem (Rail)</h6>
                <p>Embarque: @StateService.TrainLoadRate.ToString("F2") TEU/h</p>
                <p>Descarga: @StateService.TrainUnloadRate.ToString("F2") TEU/h</p>
            </div>
        </div>
    </div>
</div>

<!-- Card: Gráfico Principal (Estoque) -->
<div class="card mb-3">
    <div class="card-header">
        <h5 class="mb-0">Análise de Janela Horária (Projeção de Estoque)</h5>
    </div>
    <div class="card-body">
        <canvas id="slotChart" width="400" height="100" style='width:100%;height:100px'></canvas>
    </div>
</div>

<!-- Card: Gráfico de Slots -->
<div class="card mb-3">
    <div class="card-header">
        <h5 class="mb-0">Resumo de Slots Sugeridos</h5>
    </div>
    <div class="card-body">
        <canvas id="slotsSummaryChart" width="400" height="100" style='width:100%;height:100px'></canvas>
    </div>
</div>

<!-- Card: Gráfico de Capacidade -->
<div class="card mb-3">
    <div class="card-header">
        <h5 class="mb-0">Dados de Capacidade (Gate e Movimentações)</h5>
    </div>
    <div class="card-body">
        <canvas id="capacityChart" width="400" height="100" style='width:100%;height:100px'></canvas>
    </div>
</div>

<!-- Card: Gráfico de Movimentação por Modal -->
<div class="card mb-3">
    <div class="card-header">
        <h5 class="mb-0">Entradas / Saídas por Modal</h5>
    </div>
    <div class="card-body">
        <canvas id="inOutChart" width="400" height="100" style='width:100%;height:100px'></canvas>
    </div>
</div>


@code {

    private double TargetPercent
    {
        get => StateService.MaxYardTeu > 0 ? Math.Round((double)StateService.TargetYardTeu / StateService.MaxYardTeu * 100, 1) : 0;
        set => StateService.TargetYardTeu = (int)(StateService.MaxYardTeu * (value / 100.0));
    }

    private double ReservePercent
    {
        get => Math.Round(StateService.ReserveRho * 100, 1);
        set => StateService.ReserveRho = value / 100.0;
    }

    private CancellationTokenSource cts;
    private DotNetObjectReference<SlotCalculatorPage>? objRef;

    private List<OracleEnvironment> oracleEnvironments = new();

    protected override async Task OnInitializedAsync()
    {
        StateService.OnChange += StateHasChanged;
        StateService.Load();

        var config = ConfigService.GetConfig();
        oracleEnvironments = config.OracleEnvironments ?? new List<OracleEnvironment>();

        StateService.InitializeState(state =>
        {
            if (string.IsNullOrEmpty(state.SelectedOracleEnvironment) && oracleEnvironments.Any())
            {
                state.SelectedOracleEnvironment = oracleEnvironments.First().Name;
            }
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("addKeyboardShortcuts", objRef);
            await UpdateChart();
            await UpdateCapacityChart();
        }
    }

    public void Dispose()
    {
        StateService.OnChange -= StateHasChanged;
        StateService.Save();
        cts?.Dispose();

        if (objRef != null)
        {
            objRef.Dispose();
        }
    }

    private void OnRangeSelect(DateRange range)
    {
        StateService.StartDate = range.Start.DateTime;
        StateService.EndDate = range.End.DateTime;
    }

    [JSInvokable]
    public async Task HandleKeyPress(string key)
    {
        if (key == "Enter")
        {
            await CalculateSlots();
        }
    }

    private async Task CalculateSlots()
    {
        try
        {
            cts?.Cancel();
            cts = new CancellationTokenSource();

            StateService.ProgressValue = 0;
            StateService.IsLoading = true;

            // Always calculate historical start
            var initialInventory = await OracleOpsService.GetHistoricalYardTeuAsync(StateService.StartDate, StateService.SelectedOracleEnvironment, cts.Token);

            // Busca dados do período selecionado
            // Removido cache para garantir dados sempre frescos
            StateService.Vessels = await OracleOpsService.FetchVesselPlansWithNamesAsync(StateService.StartDate.AddDays(-7), StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            StateService.Rails = await OracleOpsService.FetchRailPlansWithNamesAsync(StateService.StartDate.AddDays(-7), StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            
            StateService.VesselSchedules = await OracleOpsService.FetchVesselSchedulesAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            StateService.RailSchedules = await OracleOpsService.FetchRailSchedulesAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);

            // Fetch both actual and average gate trucks
            var actualGate = await OracleOpsService.FetchActualGateTrucksAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            var avgGate = await OracleOpsService.FetchGateTrucksAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            
            // Always fetch actual history
            StateService.ActualHistory = await OracleOpsService.FetchActualYardInventoryHistoryAsync(StateService.StartDate, StateService.EndDate, initialInventory, StateService.SelectedOracleEnvironment, cts.Token);

            // Merge: Use actuals if T < Now and they contain data, otherwise averages
            StateService.GateTrucks = new Dictionary<DateTime, Common.Services.Interfaces.InOut>();
            foreach(var kvp in avgGate) {
                if (kvp.Key < DateTime.Now && actualGate.TryGetValue(kvp.Key, out var act) && (act.In > 0 || act.Out > 0)) {
                    StateService.GateTrucks[kvp.Key] = act;
                } else {
                    StateService.GateTrucks[kvp.Key] = kvp.Value;
                }
            }
            
            StateService.YardMoves = await OracleOpsService.FetchYardMovesAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            StateService.CachedStartDate = StateService.StartDate;
            StateService.CachedEndDate = StateService.EndDate;
            StateService.CachedEnvironment = StateService.SelectedOracleEnvironment;

            var gateTrucks = StateService.GateTrucks;
            var yardMoves = StateService.YardMoves;

            var caps = new Dictionary<DateTime, OpsCaps>();

            for (var t = StateService.StartDate; t <= StateService.EndDate; t = t.AddHours(1))
            {
                var gateData = gateTrucks.TryGetValue(t, out var gt) ? gt : null;
                var yardMoveCount = yardMoves.TryGetValue(t, out var ym) ? ym : StateService.YardMovesPerHour;

                // Fallback for future hours if no specific gate plan is provided (assuming gateTrucks dict only has history/avg)
                int inCap = gateData?.In ?? (StateService.GateTrucksPerHour / 2);
                int outCap = gateData?.Out ?? (StateService.GateTrucksPerHour / 2);
                int vesselIn = gateData?.VesselIn ?? 0;
                int vesselOut = gateData?.VesselOut ?? 0;
                int railIn = gateData?.RailIn ?? 0;
                int railOut = gateData?.RailOut ?? 0;
                int otherIn = gateData?.OtherIn ?? 0;
                int otherOut = gateData?.OtherOut ?? 0;

                caps[t] = new OpsCaps(t, inCap, outCap, yardMoveCount, vesselIn, vesselOut, railIn, railOut, otherIn, otherOut);
            }

            var band = new YardBand(StateService.MinYardTeu, StateService.TargetYardTeu, StateService.MaxYardTeu);

            var vesselRates = await OracleOpsService.GetVesselLoadUnloadRatesAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            var trainRates = await OracleOpsService.GetTrainLoadUnloadRatesAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);
            var avgTeuPerTruck = await OracleOpsService.GetAvgTeuPerTruckAsync(StateService.StartDate, StateService.EndDate, StateService.SelectedOracleEnvironment, cts.Token);

            StateService.VesselLoadRate = vesselRates?.LoadRateTeusPerHour ?? 0;
            StateService.VesselUnloadRate = vesselRates?.UnloadRateTeusPerHour ?? 0;
            StateService.TrainLoadRate = trainRates?.LoadRateTeusPerHour ?? 0;
            StateService.TrainUnloadRate = trainRates?.UnloadRateTeusPerHour ?? 0;
            StateService.AvgTeuPerTruck = avgTeuPerTruck;

            StateService.HourWindows = SlotCalculator.ComputeHourWindows(
                StateService.StartDate,
                StateService.EndDate,
                initialInventory,
                StateService.Vessels,
                StateService.Rails,
                caps,
                StateService.ActualHistory,
                band,
                StateService.AvgTeuPerTruck,
                StateService.ReserveRho,
                StateService.EasingStrength,
                StateService.VesselLoadRate,
                StateService.VesselUnloadRate,
                StateService.TrainLoadRate,
                StateService.TrainUnloadRate
            ).ToList();

            StateService.ChartData = StateService.HourWindows.Select(hw => new SlotChartData
            {
                Timestamp = hw.T.ToString("o"),
                TotalSlots = hw.TotalSlots,
                SlotsIn = hw.SlotsIn,
                SlotsOut = hw.SlotsOut,
                MinYardTeu = StateService.MinYardTeu,
                TargetYardTeu = StateService.TargetYardTeu,
                MaxYardTeu = StateService.MaxYardTeu,
                YardTeuProjection = hw.YardTeuProjection,
                YardTeuNoGate = hw.YardTeuNoGate,
                YardTeuRealGate = hw.YardTeuRealGate,
                TruckIn = hw.TruckIn,
                TruckOut = hw.TruckOut,
                VesselIn = hw.VesselIn,
                VesselOut = hw.VesselOut,
                RailIn = hw.RailIn,
                RailOut = hw.RailOut,
                SimVesselDiff = hw.SimVesselDiff,
                SimRailDiff = hw.SimRailDiff,
                SimTruckDiff = hw.SimTruckDiff,
                RealVesselDiff = hw.RealVesselDiff,
                RealRailDiff = hw.RealRailDiff,
                RealTruckDiff = hw.RealTruckDiff
            }).ToList();

            // Store capacity data for charting
            StateService.CapacityData = caps.Select(kvp => new CapacityChartData
            {
                Timestamp = kvp.Key.ToString("o"),
                GateTrucksIn = kvp.Value.GateTrucksInPerHour,
                GateTrucksOut = kvp.Value.GateTrucksOutPerHour,
                YardMoves = kvp.Value.YardMovesPerHour
            }).ToList();

            await UpdateChart();
            await UpdateCapacityChart();
        }
        catch (OperationCanceledException)
        {

        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erro ao calcular slots: {Message}", ex.Message);
            toastService.ShowError($"Erro ao calcular slots: {ex.Message}");
        }
        finally
        {
            StateService.IsLoading = false;
        }
    }

    private void CancelCalculation()
    {
        StateService.IsLoading = false;
        cts?.Cancel();
    }

    private async Task ResetAllZoom()
    {
        await JSRuntime.InvokeVoidAsync("resetAllZooms");
    }

    private async Task UpdateChart()
    {
        if (StateService.ChartData == null || !StateService.ChartData.Any()) return;

        var now = DateTime.Now;
        var labels = StateService.ChartData.Select(d => DateTime.Parse(d.Timestamp).ToString("dd/MM HH:mm")).ToArray();
        
        int nowIndex = -1;
        double minDiff = double.MaxValue;
        for (int i = 0; i < StateService.ChartData.Count; i++)
        {
            var t = DateTime.Parse(StateService.ChartData[i].Timestamp);
            var diff = Math.Abs((t - now).TotalMinutes);
            if (diff < minDiff)
            {
                minDiff = diff;
                nowIndex = i;
            }
        }

        var dataTotalSlots = StateService.ChartData.Select(d => d.TotalSlots).ToArray();
        var dataSlotsIn = StateService.ChartData.Select(d => d.SlotsIn).ToArray();
        var dataSlotsOut = StateService.ChartData.Select(d => d.SlotsOut).ToArray();
        var minYardTeu = StateService.ChartData.Select(d => d.MinYardTeu).ToArray();
        var targetYardTeu = StateService.ChartData.Select(d => d.TargetYardTeu).ToArray();
        var maxYardTeu = StateService.ChartData.Select(d => d.MaxYardTeu).ToArray();
        var yardTeuProjection = StateService.ChartData.Select(d => d.YardTeuProjection).ToArray();

        var yardTeuNoGate = StateService.ChartData.Select(d => d.YardTeuNoGate).ToArray();
        var yardTeuRealGate = StateService.ChartData.Select(d => {
            var t = DateTime.Parse(d.Timestamp);
            return t > now ? (double?)null : d.YardTeuRealGate;
        }).ToArray();

        var truckIn = StateService.ChartData.Select(d => d.TruckIn).ToArray();
        var truckOut = StateService.ChartData.Select(d => d.TruckOut).ToArray();
        var vesselIn = StateService.ChartData.Select(d => d.VesselIn).ToArray();
        var vesselOut = StateService.ChartData.Select(d => d.VesselOut).ToArray();

        var railIn = StateService.ChartData.Select(d => d.RailIn).ToArray();
        var railOut = StateService.ChartData.Select(d => d.RailOut).ToArray();

        var simVesselDiff = StateService.ChartData.Select(d => d.SimVesselDiff).ToArray();
        var simRailDiff = StateService.ChartData.Select(d => d.SimRailDiff).ToArray();
        var simTruckDiff = StateService.ChartData.Select(d => d.SimTruckDiff).ToArray();
        var realVesselDiff = StateService.ChartData.Select(d => d.RealVesselDiff).ToArray();
        var realRailDiff = StateService.ChartData.Select(d => d.RealRailDiff).ToArray();
        var realTruckDiff = StateService.ChartData.Select(d => d.RealTruckDiff).ToArray();

        var workLines = new List<object>();
        var chartTimestamps = StateService.ChartData.Select(d => DateTime.Parse(d.Timestamp)).ToList();

        // foreach (var v in StateService.VesselSchedules)
        // {
        //     int startIdx = v.StartWork.HasValue ? FindClosestIndex(chartTimestamps, v.StartWork.Value) : -1;
        //     int endIdx = v.EndWork.HasValue ? FindClosestIndex(chartTimestamps, v.EndWork.Value) : -1;

        //     if (startIdx != -1) workLines.Add(new { index = startIdx, color = "blue", label = $"Start: {v.VesselName}", dash = new[] { 2, 2 } });
        //     if (endIdx != -1) workLines.Add(new { index = endIdx, color = "darkblue", label = $"End: {v.VesselName}", dash = new[] { 2, 2 } });
        // }

        // foreach (var r in StateService.RailSchedules)
        // {
        //     int startIdx = r.StartWork.HasValue ? FindClosestIndex(chartTimestamps, r.StartWork.Value) : -1;
        //     int endIdx = r.EndWork.HasValue ? FindClosestIndex(chartTimestamps, r.EndWork.Value) : -1;

        //     if (startIdx != -1) workLines.Add(new { index = startIdx, color = "green", label = $"Start: {r.TrainName}", dash = new[] { 2, 2 } });
        //     if (endIdx != -1) workLines.Add(new { index = endIdx, color = "darkgreen", label = $"End: {r.TrainName}", dash = new[] { 2, 2 } });
        // }
        // foreach (var v in StateService.VesselSchedules)
        // {
        //     int startIdx = v.StartWork.HasValue ? FindClosestIndex(chartTimestamps, v.StartWork.Value) : -1;
        //     int endIdx = v.EndWork.HasValue ? FindClosestIndex(chartTimestamps, v.EndWork.Value) : -1;

        //     if (startIdx != -1) workLines.Add(new { index = startIdx, color = "blue", label = $"Start: {v.VesselName}", dash = new[] { 2, 2 } });
        //     if (endIdx != -1) workLines.Add(new { index = endIdx, color = "darkblue", label = $"End: {v.VesselName}", dash = new[] { 2, 2 } });
        // }

        // foreach (var r in StateService.RailSchedules)
        // {
        //     int startIdx = r.StartWork.HasValue ? FindClosestIndex(chartTimestamps, r.StartWork.Value) : -1;
        //     int endIdx = r.EndWork.HasValue ? FindClosestIndex(chartTimestamps, r.EndWork.Value) : -1;

        //     if (startIdx != -1) workLines.Add(new { index = startIdx, color = "green", label = $"Start: {r.TrainName}", dash = new[] { 2, 2 } });
        //     if (endIdx != -1) workLines.Add(new { index = endIdx, color = "darkgreen", label = $"End: {r.TrainName}", dash = new[] { 2, 2 } });
        // }

        int?[]? actualInventory = null;
        if (StateService.ActualHistory != null && StateService.ActualHistory.Any())
        {
             actualInventory = StateService.ChartData.Select(d => {
                var t = DateTime.Parse(d.Timestamp);
                var normalizedT = new DateTime(t.Year, t.Month, t.Day, t.Hour, 0, 0);
                if (normalizedT > now) return (int?)null;
                return StateService.ActualHistory.TryGetValue(normalizedT, out var val) ? (int?)val : null;
            }).ToArray();
            
            // If all values are null, it means we don't have actual data for this window (e.g. all future)
            if (actualInventory.All(x => x == null)) actualInventory = null;
        }

        // Per-class data
        var classDatasets = new List<object>();
        // Palette mantida para consistência visual
        var palette = new[]
        {
            "rgb(255,99,132)",
            "rgb(54,162,235)",
            "rgb(255,206,86)",
            "rgb(75,192,192)",
            "rgb(153,102,255)",
            "rgb(255,159,64)",
            "rgb(199,199,199)",
            "rgb(0,128,0)",
            "rgb(128,0,128)",
            "rgb(0,0,0)"
        };
        int colorIndex = 0;



        // Convert vessels and rails data to JavaScript-compatible format
        // Formato da chave ajustado para corresponder ao label (dd/MM HH:mm) pode ser necessário dependendo do JS
        // Mas mantendo yyyy-MM-dd HH:mm para compatibilidade com o objeto Date do JS se for parseado lá
        var vesselsData = new Dictionary<string, string[]>();
        var railsData = new Dictionary<string, string[]>();

        foreach (var kvp in StateService.Vessels)
        {
            var key = kvp.Key.ToString("yyyy-MM-dd HH:mm");
            vesselsData[key] = kvp.Value.VesselNames.ToArray();
        }

        foreach (var kvp in StateService.Rails)
        {
            var key = kvp.Key.ToString("yyyy-MM-dd HH:mm");
            railsData[key] = kvp.Value.TrainNames.ToArray();
        }

        var datasets = new List<object>
        {
            new
            {
            label = "Meta de Estoque (Target)", // Traduzido
            data = targetYardTeu,
            borderColor = "rgba(0,128,0,0.5)",
            borderDash = new[] {5,5},
            pointRadius = 0,
            fill = false
            },
            new
            {
            label = "Projeção Estoque (Sem Gate)", // Traduzido
            data = yardTeuNoGate,
            borderColor = "rgb(128,128,128)",
            tension = 0.4,
            cubicInterpolationMode = "monotone",
            pointRadius = 0
            },
            new
            {
            label = "Projeção Real (Gate Atual)", // Traduzido
            data = yardTeuRealGate,
            borderColor = "rgb(255, 165, 0)", // Orange
            tension = 0.4,
            cubicInterpolationMode = "monotone",
            pointRadius = 0
            },
            new
            {
            label = "Projeção Estoque (Ótima)", // Traduzido
            data = yardTeuProjection,
            borderColor = "rgb(0, 128, 255)",
            tension = 0.4,
            cubicInterpolationMode = "monotone",
            pointRadius = 0
            },
            new
            {
                label = "Simulação (Apenas Navio)",
                data = simVesselDiff,
                borderColor = "rgb(0, 0, 255)",
                borderDash = new[] { 5, 5 },
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
            new
            {
                label = "Simulação (Apenas Trem)",
                data = simRailDiff,
                borderColor = "rgb(0, 128, 0)",
                borderDash = new[] { 5, 5 },
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
            new
            {
                label = "Simulação (Apenas Gate)",
                data = simTruckDiff,
                borderColor = "rgb(255, 165, 0)",
                borderDash = new[] { 5, 5 },
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
            new
            {
                label = "Real (Apenas Navio)",
                data = realVesselDiff,
                borderColor = "rgb(0, 0, 139)",
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
            new
            {
                label = "Real (Apenas Trem)",
                data = realRailDiff,
                borderColor = "rgb(0, 100, 0)",
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
            new
            {
                label = "Real (Apenas Gate)",
                data = realTruckDiff,
                borderColor = "rgb(255, 140, 0)",
                tension = 0.4,
                pointRadius = 0,
                hidden = true
            },
        };
        
        if (actualInventory != null)
        {
             datasets.Add(new
            {
                label = "Estoque Real (Histórico)", // Traduzido
                data = actualInventory,
                borderColor = "rgb(255, 99, 132)",
                borderDash = new[] {2,2},
                tension = 0.4,
                cubicInterpolationMode = "monotone",
                pointRadius = 0
            });
        }

        var chartData = new
        {
            type = "line",
            data = new
            {
                labels = labels,
                datasets = datasets
            },
            options = new
            {
                responsive = true,
                scales = new
                {
                    y = new
                    {
                        //beginAtZero = true,
                        title = new
                        {
                            display = true,
                            text = "TEUs"
                        }
                    },
                    x = new
                    {
                        title = new
                        {
                            display = true,
                            text = "Hora" // Traduzido
                        }
                    }
                },
                plugins = new
                {
                    tooltip = new
                    {
                        mode = "index",
                        intersect = false
                    },
                    verticalLine = new
                    {
                        index = nowIndex,
                        color = "red",
                        label = "Agora"
                    },
                    workLines = workLines
                }
            },
            vessels = vesselsData,
            rails = railsData
        };
        await JSRuntime.InvokeVoidAsync("renderChart", "slotChart", chartData);

        var inOutDatasets = new List<object>
                {
                    new
                    {
                        label = "Caminhão (Entrada)", // Traduzido
                        data = truckIn,
                        borderColor = "rgb(0,200,0)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Caminhão (Saída)", // Traduzido
                        data = truckOut,
                        borderColor = "rgb(200,0,0)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Navio (Entrada)", // Traduzido
                        data = vesselIn,
                        borderColor = "rgb(0,0,200)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Navio (Saída)", // Traduzido
                        data = vesselOut,
                        borderColor = "rgb(200,0,200)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Trem (Entrada)", // Traduzido
                        data = railIn,
                        borderColor = "rgb(128,128,0)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Trem (Saída)", // Traduzido
                        data = railOut,
                        borderColor = "rgb(0,128,128)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    }
                };

        var inOutChartData = new
        {
            type = "line",
            data = new
            {
                labels = labels,
                datasets = inOutDatasets
            },
            options = new
            {
                responsive = true,
                plugins = new
                {
                    tooltip = new
                    {
                        mode = "index",
                        intersect = false
                    },
                    verticalLine = new
                    {
                        index = nowIndex,
                        color = "red",
                        label = "Agora"
                    }
                },
                scales = new
                {
                    y = new
                    {
                        title = new
                        {
                            display = true,
                            text = "TEUs"
                        }
                    },
                    x = new
                    {
                        title = new
                        {
                            display = true,
                            text = "Hora" // Traduzido
                        }
                    }
                }
            },
            vessels = vesselsData,
            rails = railsData
        };

        await JSRuntime.InvokeVoidAsync("renderChart", "inOutChart", inOutChartData);

        var slotsSummaryDatasets = new List<object>
                {
                    new
                    {
                        label = "Total de Slots", // Traduzido
                        data = dataTotalSlots,
                        borderColor = "rgb(75, 192, 192)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Slots (Entrada)", // Traduzido
                        data = dataSlotsIn,
                        borderColor = "rgb(235, 64, 52)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Slots (Saída)", // Traduzido
                        data = dataSlotsOut,
                        borderColor = "rgb(153, 102, 255)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    }
                };

        var slotsSummaryChartData = new
        {
            type = "line",
            data = new
            {
                labels = labels,
                datasets = slotsSummaryDatasets
            },
            options = new
            {
                responsive = true,
                plugins = new
                {
                    tooltip = new
                    {
                        mode = "index",
                        intersect = false,
                        enabled = true
                    },
                    verticalLine = new
                    {
                        index = nowIndex,
                        color = "red",
                        label = "Agora"
                    }
                },
                interaction = new
                {
                    mode = "nearest",
                    axis = "x",
                    intersect = false
                }
            }
        };

        await JSRuntime.InvokeVoidAsync("renderChart", "slotsSummaryChart", slotsSummaryChartData);
    }


    private async Task UpdateCapacityChart()
    {
        if (StateService.CapacityData == null || !StateService.CapacityData.Any()) return;

        var now = DateTime.Now;
        var labels = StateService.CapacityData.Select(d => DateTime.Parse(d.Timestamp).ToString("dd/MM HH:mm")).ToArray();
        var gateTrucksIn = StateService.CapacityData.Select(d => d.GateTrucksIn).ToArray();
        var gateTrucksOut = StateService.CapacityData.Select(d => d.GateTrucksOut).ToArray();
        var yardMoves = StateService.CapacityData.Select(d => d.YardMoves).ToArray();

        int nowIndex = -1;
        double minDiff = double.MaxValue;
        for (int i = 0; i < StateService.CapacityData.Count; i++)
        {
            var t = DateTime.Parse(StateService.CapacityData[i].Timestamp);
            var diff = Math.Abs((t - now).TotalMinutes);
            if (diff < minDiff)
            {
                minDiff = diff;
                nowIndex = i;
            }
        }

        var capacityDatasets = new List<object>
                {
                    new
                    {
                        label = "Caminhões Gate (Entrada)", // Traduzido
                        data = gateTrucksIn,
                        borderColor = "rgb(0, 200, 0)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Caminhões Gate (Saída)", // Traduzido
                        data = gateTrucksOut,
                        borderColor = "rgb(200, 0, 0)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    },
                    new
                    {
                        label = "Movimentações de Pátio", // Traduzido
                        data = yardMoves,
                        borderColor = "rgb(0, 0, 200)",
                        tension = 0.4,
                        cubicInterpolationMode = "monotone",
                        pointRadius = 0
                    }
                };

        var capacityChartData = new
        {
            type = "line",
            data = new
            {
                labels = labels,
                datasets = capacityDatasets
            },
            options = new
            {
                responsive = true,
                scales = new
                {
                    y = new
                    {
                        //beginAtZero = true,
                        title = new
                        {
                            display = true,
                            text = "Quantidade" // Traduzido
                        }
                    },
                    x = new
                    {
                        title = new
                        {
                            display = true,
                            text = "Hora" // Traduzido
                        }


                    }
                },
                plugins = new
                {
                    tooltip = new
                    {
                        mode = "index",
                        intersect = false
                    },
                    verticalLine = new
                    {
                        index = nowIndex,
                        color = "red",
                        label = "Agora"
                    }
                }
            }
        };

        await JSRuntime.InvokeVoidAsync("renderChart", "capacityChart", capacityChartData);
    }

    private int FindClosestIndex(List<DateTime> timestamps, DateTime target)
    {
        if (timestamps == null || !timestamps.Any()) return -1;
        
        int closestIndex = -1;
        double minDiff = double.MaxValue;
        
        for (int i = 0; i < timestamps.Count; i++)
        {
            var diff = Math.Abs((timestamps[i] - target).TotalMinutes);
            if (diff < minDiff)
            {
                minDiff = diff;
                closestIndex = i;
            }
        }
        
        // Only return if it's reasonably close (e.g. within 30 mins of the hour slot)
        return minDiff <= 30 ? closestIndex : -1;
    }
}
