using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Generation
{
    /// <summary>
    /// Source generator that creates state management services for classes ending with 'State'.
    /// </summary>
    [Generator]
    public class StateGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register syntax provider to find classes ending with 'State'
            var syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) =>
                {
                    // Quick check if it's a class
                    if (node is not ClassDeclarationSyntax classDeclaration)
                        return false;

                    // Check if class name ends with "State" and is public
                    return classDeclaration.Identifier.Text.EndsWith("State", StringComparison.Ordinal) &&
                           classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)) &&
                           !classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.AbstractKeyword));
                },
                transform: (generatorSyntaxContext, _) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorSyntaxContext.Node;
                    var model = generatorSyntaxContext.SemanticModel;

                    // Get semantic information about the class
                    var symbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                    if (symbol == null) return default;

                    return (classDeclaration, symbol);
                });

            // Collect all state classes to generate the registration extension
            var stateClassesProvider = syntaxProvider.Collect();

            // Register individual state services
            context.RegisterSourceOutput(syntaxProvider, (context, tuple) =>
            {
                if (tuple.symbol == null)
                {
                    return; // Skip if no valid symbol (transform returned default)
                }

                try
                {
                    var namespaceName = tuple.symbol.ContainingNamespace.ToDisplayString();
                    var className = tuple.symbol.Name;
                    var serviceName = $"{className}Service";

                    // Get all properties from the state class
                    var properties = tuple.symbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                        .ToList();

                    var source = GenerateStateServiceSource(namespaceName, className, serviceName, properties);
                    context.AddSource($"{serviceName}.g.cs", SourceText.From(source, Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "SG002",
                            "Generation failed",
                            "Failed to generate state service: {0}",
                            "StateGenerator",
                            DiagnosticSeverity.Error,
                            true),
                        Location.None,
                        ex.Message));
                }
            });

            // Register the extension method for DI registration
            context.RegisterSourceOutput(stateClassesProvider, (context, stateClasses) =>
            {
                var registrationSource = GenerateRegistrationExtensionSource(stateClasses
                    .Where(tuple => tuple.symbol != null)
                    .Select(tuple => (
                        Namespace: tuple.symbol!.ContainingNamespace.ToDisplayString(),
                        ClassName: tuple.symbol.Name,
                        ServiceName: $"{tuple.symbol.Name}Service"
                    ))
                    .ToList());

                context.AddSource("StateServiceRegistration.g.cs", SourceText.From(registrationSource, Encoding.UTF8));
            });
        }

        private static string GenerateRegistrationExtensionSource(List<(string Namespace, string ClassName, string ServiceName)> services)
        {
            var registrations = new StringBuilder();
            foreach (var service in services)
            {
                registrations.AppendLine($"            services.AddScoped<{service.Namespace}.{service.ServiceName}>();");
            }

            return $@"// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace Generation
{{
    /// <summary>
    /// Extension methods for registering state services in the DI container.
    /// </summary>
    public static class StateServiceRegistrationExtensions
    {{
        /// <summary>
        /// Adds all state services to the service collection as scoped services.
        /// </summary>
        /// <param name=""services"">The service collection to add the services to.</param>
        /// <returns>The service collection for chaining.</returns>
        public static IServiceCollection AddStateServices(this IServiceCollection services)
        {{
{registrations}
            return services;
        }}
    }}
}}";
        }

        private static string GenerateStateServiceSource(string namespaceName, string className, string serviceName, List<IPropertySymbol> properties)
        {
            var propertyAccessors = new StringBuilder();
            var collectionMethods = new StringBuilder();

            foreach (var property in properties)
            {
                // Generate property accessor
                propertyAccessors.AppendLine($@"
        /// <summary>
        /// Gets or sets the {property.Name}.
        /// </summary>
        public {property.Type} {property.Name}
        {{
            get => _state.{property.Name};
            set
            {{
                _state.{property.Name} = value;
                NotifyStateChanged();
            }}
        }}");

                // Generate collection-specific methods if property is a collection
                if (property.Type.ToString().StartsWith("System.Collections.Generic.List<"))
                {
                    var itemType = property.Type.ToString().Replace("System.Collections.Generic.List<", "").TrimEnd('>');
                    collectionMethods.AppendLine($@"
        /// <summary>
        /// Adds an item to {property.Name}.
        /// </summary>
        public void Add{property.Name.TrimEnd('s')}({itemType} item)
        {{
            _state.{property.Name}.Add(item);
            NotifyStateChanged();
        }}

        /// <summary>
        /// Removes an item from {property.Name}.
        /// </summary>
        public void Remove{property.Name.TrimEnd('s')}({itemType} item)
        {{
            _state.{property.Name}.Remove(item);
            NotifyStateChanged();
        }}");
                }
                else if (property.Type.ToString().StartsWith("System.Collections.Generic.Dictionary<"))
                {
                    var types = property.Type.ToString()
                        .Replace("System.Collections.Generic.Dictionary<", "")
                        .TrimEnd('>')
                        .Split(',');
                    var keyType = types[0].Trim();
                    var valueType = types[1].Trim();

                    collectionMethods.AppendLine($@"
        /// <summary>
        /// Sets the {property.Name} dictionary.
        /// </summary>
        public void Set{property.Name}(Dictionary<{keyType}, {valueType}> values)
        {{
            _state.{property.Name} = values;
            NotifyStateChanged();
        }}");
                }
            }

            return $@"// <auto-generated/>
using System;
using System.Collections.Generic;

namespace {namespaceName}
{{
    /// <summary>
    /// Auto-generated state management service for {className}.
    /// </summary>
    public partial class {serviceName}
    {{
        private {className} _state = new();

        /// <summary>
        /// Event that is raised when the state changes.
        /// </summary>
        public event Action? OnChange;

        /// <summary>
        /// Notifies listeners that the state has changed.
        /// </summary>
        protected virtual void NotifyStateChanged() => OnChange?.Invoke();

        /// <summary>
        /// Gets the current state.
        /// </summary>
        /// <returns>The current state instance.</returns>
        public {className} GetState() => _state;

        /// <summary>
        /// Updates the state using the provided action and notifies listeners.
        /// </summary>
        /// <param name=""updateAction"">Action that modifies the state.</param>
        protected void UpdateState(Action<{className}> updateAction)
        {{
            if (updateAction == null)
                throw new ArgumentNullException(nameof(updateAction));

            updateAction(_state);
            NotifyStateChanged();
        }}{propertyAccessors}{collectionMethods}
    }}
}}";
        }
    }
}
